package com.yeespec.microscope.utils;import android.content.Context;import android.graphics.Bitmap;import android.graphics.Matrix;import android.os.Environment;import android.text.TextUtils;import android.util.Log;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.RandomAccessFile;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import io.netty.channel.pool.FixedChannelPool;/*存储图片 */public class FileUtils {    protected static final boolean DEBUG = false;    //private static final String TAG = FileUtils.class.getSimpleName();    // public static final String DIR_NAME = "USBCameraTest";  /*  public static  String DIR_NAME;    public static String SDPATH = Environment.getExternalStorageDirectory()            + "/formats/";*////保存bitmap到path;   /* private static void savabitmap(Bitmap bitmap,String path){        FileOutputStream fos =null;        try {            fos = new FileOutputStream(path);            if (bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos)) {                fos.flush();            }        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }   */        //文件重命名    public static void fileRemane(String oldPath, String oldScaledPath, String newPath, String newScaledPath,String oldScaledjpgPath,String newScaledjpgPath){        File file = new File(oldPath);        File newFile = new File(newPath);        File scaledFile = new File(oldScaledPath);        File newScalFile = new File(newScaledPath);        File scalejpgdFile = new File(oldScaledjpgPath);        File newScaljpgFile = new File(newScaledjpgPath);        if(file!=null){               file.renameTo(newFile);        }        if(scaledFile!=null){               scaledFile.renameTo(newScalFile);        }        if(scalejpgdFile!=null){               scalejpgdFile.renameTo(newScaljpgFile);        }        System.gc();    }    public static void saveFileString(String filePath, String str,String filename){        FileOutputStream fos = null;        try {            File file = new File(filePath);            if(!file.exists())                file.mkdirs();            fos = new FileOutputStream(new File(file,filename));            fos.write(str.getBytes());            fos.flush();        } catch (FileNotFoundException e) {            e.printStackTrace();        }catch(IOException e){            e.printStackTrace();        }finally{            try {                if(null!=fos)                    fos.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    public static String getFileString(String filePath,String filename){        FileInputStream fis = null;        byte[] mByte = new byte[512];        try {            File file = new File(filePath, filename);            if(file==null||!file.isFile())                return null;            fis = new FileInputStream(file);            fis.read(mByte);        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally{            try {                if(null!=fis)                    fis.close();            } catch (IOException e) {                e.printStackTrace();            }        }        return new String(mByte).toString();    }    public static ExecutorService executorService = Executors.newFixedThreadPool(1);    public  static  void writeFileToLogFolder(final String info){        executorService.execute(new Runnable() {            @Override            public void run() {                String mfileName = MDateUtils.getTodayDateTimes()+".txt";                int year = Integer.valueOf(mfileName.substring(0, 4));                String folderPath = Environment.getExternalStorageDirectory()+"/log";                File files = new File(folderPath);                File[] allFiles = files.listFiles();                boolean isContains = false;                int minIndex = 0;                //时间没有初始化，把这部分信息存储到最近日期的文件夹中                if(year<2017){                    if(allFiles!=null) {                        for (int i = 0; i < allFiles.length; i++) {                            if (allFiles[i].lastModified() > allFiles[minIndex].lastModified()) {                                minIndex = i;                            }                        }                        String filename = allFiles[minIndex].getName();                        Log.w("FileUtils", "filename=" + filename);                        String mfolder= "/log";                        writeFileToSDCard(("             :"+info).getBytes(),mfolder,filename,true,true);                    }else{                        String mfolder= "/log";                        writeFileToSDCard(("             :"+info).getBytes(),mfolder,mfileName,true,true);                    }                }else {                    if(allFiles!=null) {                        if (allFiles.length > 6) {                            for (int i = 0; i < allFiles.length; i++) {                                if (mfileName.equals(allFiles[i])) {                                    isContains = true;                                }                                if (allFiles[i].lastModified() < allFiles[minIndex].lastModified()) {                                    minIndex = i;                                }                                // Log.w("FileUtils", "allFiles=" + allFiles[i].getName());                            }                            //超过七天的记录                            if (!isContains) {                                allFiles[minIndex].delete();//删除最小时间记录的文件                            }                        }                    }                    String mfolder= "/log";                    String currentTime = MDateUtils.getCurrentTime();                    writeFileToSDCard((currentTime+":"+info).getBytes(),mfolder,mfileName,true,true);                }            }        });    } /* 此方法为android程序写入sd文件文件，用到了android-annotation的支持库@ ** * @param buffer   写入文件的内容* @param folder   保存文件的文件夹名称,如log；可为null，默认保存在sd卡根目录* @param fileName 文件名称，默认app_log.txt* @param append   是否追加写入，true为追加写入，false为重写文件* @param autoLine 针对追加模式，true为增加时换行，false为增加时不换行*/    public synchronized static void writeFileToSDCard(final byte[] buffer,  final String folder,                                                     final String fileName, final boolean append, final boolean autoLine) {                boolean sdCardExist = Environment.getExternalStorageState().equals(                        android.os.Environment.MEDIA_MOUNTED);                String folderPath = "";                if (sdCardExist) {                    //TextUtils为android自带的帮助类                    if (TextUtils.isEmpty(folder)) {                        //如果folder为空，则直接保存在sd卡的根目录                        folderPath = Environment.getExternalStorageDirectory()                                + File.separator;                    } else {                        folderPath = Environment.getExternalStorageDirectory()                                + File.separator + folder + File.separator;                    }                } else {                    return;                }                File fileDir = new File(folderPath);                if (!fileDir.exists()) {                    if (!fileDir.mkdirs()) {                        return;                    }                }                File file;                //判断文件名是否为空                if (TextUtils.isEmpty(fileName)) {                    file = new File(folderPath + "app_log.txt");                } else {                    file = new File(folderPath + fileName);                }                RandomAccessFile raf = null;                FileOutputStream out = null;                try {                    if (append) {                        //如果为追加则在原来的基础上继续写文件                        raf = new RandomAccessFile(file, "rw");                        raf.seek(file.length());                        raf.write(buffer);                        if (autoLine) {                            raf.write("\n".getBytes());                        }                    } else {                        //重写文件，覆盖掉原来的数据                        out = new FileOutputStream(file);                        out.write(buffer);                        out.flush();                    }                } catch (IOException e) {                    e.printStackTrace();                } finally {                    try {                        if (raf != null) {                            raf.close();                        }                        if (out != null) {                            out.close();                        }                    } catch (IOException e) {                        e.printStackTrace();                    }                }    }/*    public static void saveBitmap(Bitmap bm, String picName) {        Log.e("", "保存图片");        FileOutputStream out = null;        try {            if (!isFileExist("")) {                File tempf = createSDDir("");            }            File f = new File(SDPATH, picName + ".JPEG");            if (f.exists()) {                f.delete();            }            out = new FileOutputStream(f);            bm.compress(Bitmap.CompressFormat.JPEG, 90, out);            out.flush();            out.close();            Log.e("", "已经保存");        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                //关闭资源输入输出流 :                if (out != null) {                    out.close();                }            } catch (Exception ex) {                ex.printStackTrace();            } finally {            }        }    }*/    /*public static File createSDDir(String dirName) throws IOException {        File dir = new File(SDPATH + dirName);        if (Environment.getExternalStorageState().equals(                Environment.MEDIA_MOUNTED)) {            System.out.println("createSDDir:" + dir.getAbsolutePath());            System.out.println("createSDDir:" + dir.mkdir());        }        return dir;    }*/   /* public static boolean isFileExist(String fileName) {        File file = new File(SDPATH + fileName);        file.isFile();        return file.exists();    }*/   /* public static void delFile(String fileName) {        File file = new File(SDPATH + fileName);        if (file.isFile()) {            file.delete();        }        file.exists();    }*/   /* public static void deleteDir() {        File dir = new File(SDPATH);        if (dir == null || !dir.exists() || !dir.isDirectory())            return;        for (File file : dir.listFiles()) {            if (file.isFile())                file.delete(); // 删除文件            else if (file.isDirectory())                deleteDir(); // 递规的方式删除文件夹        }        dir.delete();// 删除目录本身    }    public static boolean fileIsExists(String path) {        try {            File f = new File(path);            if (!f.exists()) {                return false;            }        } catch (Exception e) {            e.printStackTrace();            return false;        }        return true;    }*/    /**     * 复制单个文件     *     * @param oldPath String 原文件路径 如：c:/fqf.txt     * @param newPath String 复制后路径 如：f:/fqf.txt     * @return boolean     */  /*  public static void copyFile(String oldPath, String newPath, String fileName) {        InputStream inStream = null; //读入原文件        FileOutputStream fs = null;        try {            int bytesum = 0;            int byteread = 0;            File oldfile = new File(oldPath);            if (oldfile.exists()) { //文件存在时                inStream = new FileInputStream(oldPath); //读入原文件                File newFileDir = new File(newPath);                createIfNoExists(newPath);                File newFile = new File(newFileDir, fileName);                createIfNoExists(newPath + fileName);                fs = new FileOutputStream(newFile);                byte[] buffer = new byte[1024];                int length;                while ((byteread = inStream.read(buffer)) != -1) {                    bytesum += byteread; //字节数 文件大小                    if (DEBUG)                        Logger.e(String.valueOf(bytesum));                    fs.write(buffer, 0, byteread);                }                inStream.close();            }        } catch (Exception e) {            System.out.println("复制单个文件操作出错:" + oldPath);            e.printStackTrace();        } finally {            try {                //关闭资源输入输出流 :                if (fs != null) {                    fs.close();                }            } catch (Exception e) {                e.printStackTrace();            } finally {                try {                    //关闭资源输入输出流 :                    if (inStream != null) {                        inStream.close();                    }                } catch (Exception e) {                    e.printStackTrace();                }            }        }    }*/    /**     * 复制整个文件夹内容     *     * @param oldPath String 原文件路径 如：c:/fqf     * @param newPath String 复制后路径 如：f:/fqf/ff     * @return boolean     */   /* public static void copyFolder(String oldPath, String newPath) {        FileInputStream input = null;        FileOutputStream output = null;        try {            (new File(newPath)).mkdirs(); //如果文件夹不存在 则建立新文件夹            File a = new File(oldPath);            String[] file = a.list();            File temp = null;            for (int i = 0; i < file.length; i++) {                if (oldPath.endsWith(File.separator)) {                    temp = new File(oldPath + file[i]);                } else {                    temp = new File(oldPath + File.separator + file[i]);                }                if (temp.isFile()) {                    input = new FileInputStream(temp);                    output = new FileOutputStream(newPath + "/" +                            (temp.getName()).toString());                    byte[] b = new byte[1024 * 5];                    int len;                    while ((len = input.read(b)) != -1) {                        output.write(b, 0, len);                    }                    output.flush();                    output.close();                    input.close();                }                if (temp.isDirectory()) {//如果是子文件夹                    copyFolder(oldPath + "/" + file[i], newPath + "/" + file[i]);                }            }        } catch (Exception e) {            System.out.println("复制整个文件夹内容操作出错");            e.printStackTrace();        } finally {            try {                //关闭资源输入输出流 :                if (output != null) {                    output.close();                }            } catch (Exception e) {                e.printStackTrace();            } finally {                try {                    //关闭资源输入输出流 :                    if (input != null) {                        input.close();                    }                } catch (Exception e) {                    e.printStackTrace();                }            }        }    }*/    /**     * 如果不存在就创建     */    public static boolean createIfNoExists(String path) {        File file = new File(path);        boolean mk = false;        if (!file.exists()) {            mk = file.mkdirs();        }        return mk;    }    public static List<String> getMovies(Context context,int page) {        int pagenum=15;        int allnum=0;        String currentUserName = ConstantUtil.getCurrentUserName(context);        List<String> list = new ArrayList<String>();        File file = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES),currentUserName);        File[] allfiles = file.listFiles();        if (allfiles == null) {            return list;        }        if(allfiles.length<pagenum*page){            allnum =allfiles.length;        }else            allnum = pagenum*page;        for (int k = 0; k < allnum; k++) {            final File fi = allfiles[k];            if (fi.isFile()) {                int idx = fi.getPath().lastIndexOf(".");                if (idx <= 0) {                    continue;                }                String suffix = fi.getPath().substring(idx);                if (suffix.toLowerCase().equals(".mp4")) {                    list.add(fi.getPath());                }            }        }        return list;    }    //更新图片预览    public static String getNewestPicture(Context context,final String type,String path) {        List<String> pictures = FileUtils.getPictures(context,type);//获得所有图片        if (pictures != null && pictures.size() > 0) {            Collections.reverse(pictures);//倒序排列            for (int i = 0; i < pictures.size(); i++) {                String s = pictures.get(i);                int j = s.indexOf(".");                 String mpath = s.substring(0, j) + ".bmp";                 if(mpath.equals(path))                     return  pictures.get(i);            }            return pictures.get(0);           /* for (int size = pictures.size(); size >=0; size--) {                int postion = size-1;                if(postion<0){                    postion =0;                }                String s = pictures.get(postion);                //Log.e("FileUtils","s="+s);                if(s.equals(ConstantUtil.currentCaptureName))                    return s;            }*/        }        return null;    }    public static List<String> getPictures(Context context,final String type) {        String currentUserName = ConstantUtil.getCurrentUserName(context);        List<String> list = new ArrayList<String>();        File file = new File(Environment.getExternalStoragePublicDirectory(type),currentUserName+"/scale");        File[] allfiles = file.listFiles();        if (allfiles == null) {            return list;        }        for (int k = 0; k < allfiles.length; k++) {            final File fi = allfiles[k];            if (fi.isFile()) {                int idx = fi.getPath().lastIndexOf(".");                if (idx <= 0) {                    continue;                }                String suffix = fi.getPath().substring(idx);                if (suffix.toLowerCase().equals(".jpg") ||                        suffix.toLowerCase().equals(".jpeg") ||                        suffix.toLowerCase().equals(".bmp") ||                        suffix.toLowerCase().equals(".png") ||                        suffix.toLowerCase().equals(".gif")) {                    list.add(fi.getPath());                }            }        }        return list;    }    public static List<String> getPictures(Context context,final String type,int page) {       //每页15张图片        int pagenum=15;        int allnum=0;        String currentUserName = ConstantUtil.getCurrentUserName(context);        List<String> list = new ArrayList<String>();        File file = new File(Environment.getExternalStoragePublicDirectory(type),currentUserName+"/scale");        File[] allfiles = file.listFiles();        if (allfiles == null) {            return list;        }        if(allfiles.length<pagenum*page){            allnum =allfiles.length;        }else            allnum = pagenum*page;        for (int k = 0; k < allnum; k++) {            final File fi = allfiles[k];            if (fi.isFile()) {               /* int idx = fi.getPath().lastIndexOf(".");                if (idx <= 0) {                    continue;                }                String suffix = fi.getPath().substring(idx);                if (suffix.toLowerCase().equals(".jpg") ||                        suffix.toLowerCase().equals(".jpeg") ||                        suffix.toLowerCase().equals(".bmp") ||                        suffix.toLowerCase().equals(".png") ||                        suffix.toLowerCase().equals(".gif")) {                    list.add(fi.getPath());                }*/                list.add(fi.getPath());            }        }        return list;    }    public static int  select= 0;    //2016.09.26 : 保存图像数据 : 同时判断是否生成缩略图 :    public static void capture(Bitmap bitmap, String path, boolean scaled,boolean isjpg) {        if (scaled) {            Matrix matrix = new Matrix();            matrix.postScale(0.1f, 0.1f);   //图像长宽缩小为0.2倍 136*104 ;            bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);        }        //20170614注释        FileOutputStream fos = null;        try {            fos = new FileOutputStream(path);            if(isjpg) {                if (bitmap.compress(Bitmap.CompressFormat.JPEG, 30, fos)) {                    fos.flush();                }            }else if(scaled){                 if (bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos)) {                    fos.flush();                }            } else {//                if (bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos)) {//                    fos.flush();//                }                int w = bitmap.getWidth(), h = bitmap.getHeight();                int[] pixels = new int[w * h];                bitmap.getPixels(pixels, 0, w, 0, 0, w, h);                byte[] rgb = addBMP_RGB_888(pixels, w, h);                byte[] header = addBMPImageHeader(rgb.length);                byte[] infos = addBMPImageInfosHeader(w, h);                byte[] buffer = new byte[54 + rgb.length];                System.arraycopy(header, 0, buffer, 0, header.length);                System.arraycopy(infos, 0, buffer, 14, infos.length);                System.arraycopy(rgb, 0, buffer, 54, rgb.length);                fos.write(buffer);            }        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                //关闭资源输入输出流 :                if (fos != null) {                    fos.close();                }                if(scaled&&(!bitmap.isRecycled())){                    bitmap.recycle();                    System.gc();                }            } catch (Exception ex) {                ex.printStackTrace();            } finally {            }        }    }    private static byte[] addBMPImageHeader(int size) {        byte[] buffer = new byte[14];        buffer[0] = 0x42;        buffer[1] = 0x4D;        buffer[2] = (byte) (size >> 0);        buffer[3] = (byte) (size >> 8);        buffer[4] = (byte) (size >> 16);        buffer[5] = (byte) (size >> 24);        buffer[6] = 0x00;        buffer[7] = 0x00;        buffer[8] = 0x00;        buffer[9] = 0x00;        buffer[10] = 0x36;        buffer[11] = 0x00;        buffer[12] = 0x00;        buffer[13] = 0x00;        return buffer;    }    private static byte[] addBMPImageInfosHeader(int w, int h) {        byte[] buffer = new byte[40];        buffer[0] = 0x28;        buffer[1] = 0x00;        buffer[2] = 0x00;        buffer[3] = 0x00;        buffer[4] = (byte) (w >> 0);        buffer[5] = (byte) (w >> 8);        buffer[6] = (byte) (w >> 16);        buffer[7] = (byte) (w >> 24);        buffer[8] = (byte) (h >> 0);        buffer[9] = (byte) (h >> 8);        buffer[10] = (byte) (h >> 16);        buffer[11] = (byte) (h >> 24);        buffer[12] = 0x01;        buffer[13] = 0x00;  //12-13图层数        buffer[14] = 0x18;        buffer[15] = 0x00;  //bitdepth        buffer[16] = 0x00;        buffer[17] = 0x00;        buffer[18] = 0x00;        buffer[19] = 0x00;        buffer[20] = 0x00;        buffer[21] = 0x00;        buffer[22] = 0x00;        buffer[23] = 0x00;        //分辨率//        buffer[24] = (byte) 0xE0;//        buffer[25] = 0x01;//        buffer[26] = 0x00;//        buffer[27] = 0x00;//        buffer[28] = 0x02;//        buffer[29] = 0x03;//        buffer[30] = 0x00;//        buffer[31] = 0x00;        buffer[24] = (byte) (h >> 0);        buffer[25] = (byte) (h >> 8);        buffer[26] = (byte) (h >> 16);        buffer[27] = (byte) (h >> 24);        buffer[28] = (byte) (h >> 0);        buffer[29] = (byte) (h >> 8);        buffer[30] = (byte) (h >> 16);        buffer[31] = (byte) (h >> 24);        //============================        buffer[32] = 0x00;        buffer[33] = 0x00;        buffer[34] = 0x00;        buffer[35] = 0x00;        buffer[36] = 0x00;        buffer[37] = 0x00;        buffer[38] = 0x00;        buffer[39] = 0x00;        return buffer;    }    private static byte[] addBMP_RGB_888(int[] b, int w, int h) {        int len = b.length;        System.out.println(b.length);        byte[] buffer = new byte[w * h * 3];        int offset = 0;        for (int i = len - 1; i >= w; i -= w) {            int end = i, start = i - w + 1;            for (int j = start; j <= end; j++) {                buffer[offset] = (byte) (b[j] >> 0);                buffer[offset + 1] = (byte) (b[j] >> 8);                buffer[offset + 2] = (byte) (b[j] >> 16);                offset += 3;            }        }        return buffer;    }    public static String  replaceFileName(String filename){        String substring = filename.substring(7);        if(substring.indexOf(".bmp")!=-1){            return substring.replace(".bmp","");        }else if(substring.indexOf(".mp4")!=-1){           return substring.replace(".mp4","");        }        return  substring;    }}